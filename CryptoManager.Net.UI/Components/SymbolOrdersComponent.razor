@using CryptoExchange.Net.SharedApis
@using CryptoManager.Net.UI.Authorization
@using CryptoManager.Net.UI.Dialogs
@using CryptoManager.Net.UI.Models
@using CryptoManager.Net.UI.Services;
@using CryptoManager.Net.UI.Services.Rest
@using CryptoManager.Net.UI.Services.Stream
@inject IDialogService DialogService
@inject OrderService OrderService
@inject AuthStateProvider AuthProvider
@inject StreamService StreamService
@inject ISnackbar Snackbar
@implements IDisposable

<MudPaper>
    <MudPaper Style="padding: 10px;">
        <MudStack Row="true" Justify="Justify.SpaceBetween" Style="border-bottom: 1px solid #444; margin-left: -10px; margin-right: -10px;">
            <MudElement HtmlTag="div" Style="padding: 0 10px">
                <MudElement HtmlTag="div" Style="@("display: inline-block; cursor:pointer; padding: 0 4px;" + (_topic != "open" ? "" : "border-bottom: 1px solid #eee;"))" @onclick="@(x => _topic = "open")">
                    <MudText Typo="Typo.body1">open orders</MudText>
                </MudElement>
                <MudElement HtmlTag="div" Style="@("display: inline-block; cursor:pointer; padding: 0 4px;" + (_topic != "closed" ? "" : "border-bottom: 1px solid #eee;"))" @onclick="@(x => _topic = "closed")">
                    <MudText Typo="Typo.body1">closed orders</MudText>
                </MudElement>
                <MudElement HtmlTag="div" Style="@("display: inline-block; cursor:pointer; padding: 0 4px;" + (_topic != "trades" ? "" : "border-bottom: 1px solid #eee;"))" @onclick="@(x => _topic = "trades")">
                    <MudText Typo="Typo.body1">trades</MudText>
                </MudElement>
            </MudElement>
            <MudIconButton Icon="@Icons.Material.Filled.Refresh" Style="margin-right: 5px; margin-top: -10px;" Size="Size.Small" OnClick="() => ReloadAsync()"></MudIconButton>
        </MudStack>
    </MudPaper>
    @if (_topic == "open")
    {
        <OrdersTableComponent Authenticated="@(AuthProvider.User?.ExchangeAuthenticated(SymbolDetails?.Exchange) == true)"
                              IncludeSymbolInfo="false"
                              Open="true"
                              FailedToRetrieve="@_connectionIssuesOpen"
                              OnTableReload="LoadOpenAsync"
                              OnOrderClick="RowClickEvent"
                              OnOrderCancel="CancelOrder"
                              @ref="_openOrdersTable" />
    }
    else if (_topic == "closed")
    {
        <OrdersTableComponent Authenticated="@(AuthProvider.User?.ExchangeAuthenticated(SymbolDetails?.Exchange) == true)"
                              IncludeSymbolInfo="false"
                              Open="false"
                              FailedToRetrieve="@_connectionIssuesClosed"
                              OnOrderClick="RowClickEvent"
                              OnTableReload="LoadClosedAsync"
                              @ref="_closedOrdersTable" />
    }
    else if (_topic == "trades")
    {
        <TradesTableComponent Authenticated="@(AuthProvider.User?.ExchangeAuthenticated(SymbolDetails?.Exchange) == true)"
                              FailedToRetrieve="@_connectionIssuesTrades"
                              OnTableReload="LoadTradesAsync"
                              @ref="_tradesTable" />
    }
</MudPaper>

@code {
    [Parameter]
    public ApiSymbolDetails? SymbolDetails { get; set; }

    private List<ApiOrder>? _openOrders;
    private bool _connectionIssuesOpen;
    private int? _openCount;

    private List<ApiOrder>? _closedOrders;
    private bool _connectionIssuesClosed;
    private int? _closedCount;

    private string? _initializedId = null;
    private OrdersTableComponent? _openOrdersTable;
    private OrdersTableComponent? _closedOrdersTable;
    private TradesTableComponent? _tradesTable;

    private bool _connectionIssuesTrades;
    private string _topic = "open";

    protected override void OnInitialized()
    {
        StreamService.OnOrderChanged += HandleOrderUpdate;
        StreamService.OnUserTradeChanged += HandleUserTradeUpdate;
    }

    private async Task ReloadAsync()
    {
        if (SymbolDetails == null)
            return;

        if (_topic == "trades")
        {
            await OrderService.UpdateUserTradesAsync(x => Task.CompletedTask, null, SymbolDetails.Id);
            _tradesTable?.Reload();
        }
        else
        {
            if (_topic == "open") 
            {
                await OrderService.UpdateOpenOrdersAsync(() => Task.CompletedTask, null, SymbolDetails.Id);
                _openOrdersTable?.Reload();
            }
            else 
            {
                await OrderService.UpdateClosedOrdersAsync(() => Task.CompletedTask, null, SymbolDetails.Exchange, SymbolDetails.BaseAsset, SymbolDetails.QuoteAsset);
                _closedOrdersTable?.Reload();
            }
        }
    }

    private Task HandleUserTradeUpdate(ApiUserTrade[] trades)
    {
        if (SymbolDetails == null)
            return Task.CompletedTask;

        if (_topic != "trades")
            return Task.CompletedTask;

        var relevantTrades = trades.Where(x => x.Exchange == SymbolDetails.Exchange && x.Id.StartsWith(SymbolDetails.Id)).ToList();
        if (relevantTrades.Any())
            _openOrdersTable?.Reload();

        return Task.CompletedTask;
    }

    private Task HandleOrderUpdate(ApiOrder[] orders)
    {
        if (SymbolDetails == null)
            return Task.CompletedTask;

        var relevantOrders = orders.Where(x => x.Exchange == SymbolDetails.Exchange && x.SymbolId.Equals(SymbolDetails.Id, StringComparison.InvariantCultureIgnoreCase)).ToList();
        foreach (var order in relevantOrders.Where(x => x.Status == SharedOrderStatus.Open))
        {
            if (_openOrders == null)
                continue;

            var existingOrder = _openOrders.SingleOrDefault(x => x.Id == order.Id);
            if (existingOrder != null)
            {
                // Update an existing open order
                UpdateOrder(existingOrder, order);
            }
            else
            {
                // New open order
                _openOrders.Insert(0, order);
                _openCount += 1;
            }
        }

        foreach (var order in relevantOrders.Where(x => x.Status != SharedOrderStatus.Open))
        {
            var existingOpenOrder = _openOrders?.SingleOrDefault(x => x.Id == order.Id);
            if (existingOpenOrder != null)
            {
                // Open order now closed
                _openOrders!.Remove(existingOpenOrder);
                _openCount--;
            }

            if (_closedOrders == null)
                continue;

            var existingOrder = _closedOrders.SingleOrDefault(x => x.Id == order.Id);
            if (existingOrder != null)
            {
                // Update an existing closed order
                UpdateOrder(existingOrder, order);
            }
            else
            {
                // New closed order
                // Should check sorting..
                _closedOrders.Insert(0, order);
                _closedCount += 1;
            }
        }

        _openOrdersTable?.Reload();
        _closedOrdersTable?.Reload();
        return Task.CompletedTask;
    }

    private void UpdateOrder(ApiOrder existing, ApiOrder update)
    {
        existing.Status = update.Status;
        existing.AveragePrice = update.AveragePrice;
        existing.QuantityFilledBase = update.QuantityFilledBase;
        existing.QuantityFilledQuote = update.QuantityFilledQuote;
    }

    public void Dispose()
    {
        StreamService.OnOrderChanged -= HandleOrderUpdate;
        StreamService.OnUserTradeChanged -= HandleUserTradeUpdate;
    }

    protected override async Task OnParametersSetAsync()
    {
        if (SymbolDetails != null && _initializedId != SymbolDetails.Id)
        {
            _initializedId = SymbolDetails.Id;

            await OrderService.UpdateOpenOrdersAsync(() => Task.CompletedTask, null, SymbolDetails.Id);
            await OrderService.UpdateClosedOrdersAsync(() => Task.CompletedTask, null, SymbolDetails.Exchange, SymbolDetails.BaseAsset, SymbolDetails.QuoteAsset);
            await OrderService.UpdateUserTradesAsync(x => Task.CompletedTask, null, SymbolDetails.Id);

            _openCount = 0;
            _openOrders = null;
            _closedCount = 0;
            _closedOrders = null;

            _openOrdersTable?.Reload();
            _closedOrdersTable?.Reload();
            _tradesTable?.Reload();
        }
    }

    public string FormatQuantity(decimal? filled, decimal? total, string asset)
    {
        if (total == null && filled == null)
            return "-";

        if (total == null)
            return filled!.Value.Normalize().ToString() + " / - " + asset;

        if (filled == null)
            return "- / " + total!.Value.Normalize().ToString() + " " + asset;

        return filled!.Value.Normalize().ToString() + " / " + total!.Value.Normalize().ToString() + " " + asset;
    }

    private async Task<TableData<ApiOrder>> LoadOpenAsync(TableState state)
    {
        if (SymbolDetails == null || AuthProvider.User?.ExchangeAuthenticated(SymbolDetails.Exchange) != true)
            return new TableData<ApiOrder>() { Items = Array.Empty<ApiOrder>(), TotalItems = 0 };

        if (_openOrders == null)
        {
            await OrderService.GetOpenOrdersAsync(
                data =>
                {
                    _openOrders = data.Items.ToList();
                    _openCount = data.TotalResults;

                    _connectionIssuesOpen = false;
                    return Task.CompletedTask;
                },
                error =>
                {
                    _connectionIssuesOpen = true;
                    return Task.CompletedTask;
                },
                SymbolDetails.Exchange,
                SymbolDetails.BaseAsset,
                SymbolDetails.QuoteAsset,
                sort: state.SortLabel,
                sortDirection: state.SortDirection.ToString(),
                page: state.Page + 1,
                pageSize: state.PageSize);
        }

        if (_openOrders == null)
            return new TableData<ApiOrder>() { Items = Array.Empty<ApiOrder>(), TotalItems = 0 };

        return new TableData<ApiOrder>() { Items = _openOrders, TotalItems = _openCount ?? 0 };
    }

    private async Task<TableData<ApiOrder>> LoadClosedAsync(TableState state)
    {
        if (SymbolDetails == null || AuthProvider.User?.ExchangeAuthenticated(SymbolDetails.Exchange) != true)
            return new TableData<ApiOrder>() { Items = Array.Empty<ApiOrder>(), TotalItems = 0 };

        if (_closedOrders == null)
        {
            await OrderService.GetClosedOrdersAsync(
                data =>
                {
                    _closedOrders = data.Items.ToList();
                    _closedCount = data.TotalResults;

                    _connectionIssuesClosed = false;
                    return Task.CompletedTask;
                },
                error =>
                {
                    _connectionIssuesClosed = true;
                    return Task.CompletedTask;
                },
                exchange: SymbolDetails.Exchange,
                baseAsset: SymbolDetails.BaseAsset,
                quoteAsset: SymbolDetails.QuoteAsset,
                sort: state.SortLabel,
                sortDirection: state.SortDirection.ToString(),
                page: state.Page + 1,
                pageSize: state.PageSize);
        }

        if (_closedOrders == null)
            return new TableData<ApiOrder>() { Items = Array.Empty<ApiOrder>(), TotalItems = 0 };

        return new TableData<ApiOrder>() { Items = _closedOrders, TotalItems = _closedCount ?? 0 };
    }

    private async Task<TableData<ApiUserTrade>> LoadTradesAsync(TableState state)
    {
        if (SymbolDetails == null || AuthProvider.User?.ExchangeAuthenticated(SymbolDetails.Exchange) != true)
            return new TableData<ApiUserTrade>() { Items = Array.Empty<ApiUserTrade>(), TotalItems = 0 };

        await OrderService.UpdateUserTradesAsync(x => Task.CompletedTask, null, SymbolDetails.Id);

        Page<ApiUserTrade>? trades = null;
        await OrderService.GetUserTradesAsync(
            data =>
            {
                trades = data;
                _connectionIssuesTrades = false;
                return Task.CompletedTask;
            },
            error =>
            {
                _connectionIssuesTrades = true;
                return Task.CompletedTask;
            },
            SymbolDetails.Id,
            sort: state.SortLabel,
            sortDirection: state.SortDirection.ToString(),
            page: state.Page + 1,
            pageSize: state.PageSize);

        if (trades == null)
            return new TableData<ApiUserTrade>() { Items = Array.Empty<ApiUserTrade>(), TotalItems = 0 };

        return new TableData<ApiUserTrade>() { Items = trades.Items, TotalItems = trades.TotalResults };
    }

    private async Task RowClickEvent(ApiOrder order)
    {
        var orderDialog = await DialogService.ShowAsync<OrderDialog>(null, new DialogParameters<OrderDialog>
        {
            { x => x.Id, order.Id },
        }, new DialogOptions
        {
            MaxWidth = MaxWidth.Large,
            FullWidth = true,
            CloseButton = true
        });
        await orderDialog.Result;
    }

    private async Task CancelOrder(ApiOrder order)
    {
        var loadingDialog = await DialogService.ShowAsync<LoadingDialog>(null, options: new DialogOptions
        {
            BackdropClick = false,
            CloseOnEscapeKey = false
        });

        await OrderService.CancelOrderAsync(
            () =>
            {
                return Task.CompletedTask;
            }, 
            null,
            order.Id);

        loadingDialog.Close();
    }
}
